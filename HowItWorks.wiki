#summary How fabricate works

== Finding dependencies automatically ==

fabricate lets you simply type `run('mycommand')`, and it will run the command and figure out its dependencies (and outputs) automatically. Next time it'll only actually execute the command if those dependencies have changed (or the outputs have been modified or don't exist).

It finds dependencies by one of two methods:

  * *File access times (atimes):* By looking at the atimes of files before and after the command was run, fabricate can figure out which files each command accesses. It also uses file modification times (mtimes) to determine the command's output files. It's fast and simple, and it works on NTFS, FAT32, and many Linux filesystems.
  * *strace:* Some file systems don't update access times, and in that case fabricate uses the Linux `strace` command to log system calls to `open()` and determines what files were read and modified that way. This is the original method used by [http://www.eecs.berkeley.edu/~billm/memoize.html Bill McCloskey's memoize].

fabricate automatically picks between these two methods. In the unusual case that neither method is supported by your system, fabricate will fall back to always running the command. (Contact us if you're having problems with your setup.)

You can of course choose your own adventure and customize how fabricate works. Just subclass the `fabricate.Builder` class and override `runner()`. See the `GccBuilder` class for an example of using gcc to determine dependencies.

== Checking for differences ==

fabricate checks whether files are different by doing an MD5 hash on their contents, using `md5_hasher()`. You can change this to use modification times like make by calling `setup(hasher=mtime_hasher)` in your build script.

You can also write your own hasher function, of course, though we've never had need to.